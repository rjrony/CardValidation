// --------------------------------------------------------------------------------------------------------------------
// <copyright file="Dynamic.cs">
//   Copyright © 2017. All rights reserved.
// </copyright>
// <autogenerated />
// --------------------------------------------------------------------------------------------------------------------

namespace Infrastructure.DynamicQuery
{
    using System;
    using System.Collections;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Diagnostics.CodeAnalysis;
    using System.Globalization;
    using System.Linq;
    using System.Linq.Expressions;
    using System.Reflection;
    using System.Reflection.Emit;
    using System.Runtime.CompilerServices;
    using System.Text;
    using System.Threading;

    using Infrastructure.Localization.Contracts;

    /// <summary>
    ///     The dynamic queryable.
    /// </summary>
    [ExcludeFromCodeCoverage]
    public static class DynamicQueryable
    {
        /// <summary>
        /// The any.
        /// </summary>
        /// <param name="source">
        /// The source.
        /// </param>
        /// <returns>
        /// The <see cref="bool"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// </exception>
        public static bool Any(this IQueryable source)
        {
            if (source == null)
            {
                throw new ArgumentNullException("source");
            }

            return (bool)source.Provider.Execute(Expression.Call(typeof(Queryable), "Any", new[] { source.ElementType }, source.Expression));
        }

        /// <summary>
        /// The count.
        /// </summary>
        /// <param name="source">
        /// The source.
        /// </param>
        /// <returns>
        /// The <see cref="int"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// </exception>
        public static int Count(this IQueryable source)
        {
            if (source == null)
            {
                throw new ArgumentNullException("source");
            }

            return
                (int)source.Provider.Execute(Expression.Call(typeof(Queryable), "Count", new[] { source.ElementType }, source.Expression));
        }

        /// <summary>
        /// The distinct query
        /// </summary>
        /// <param name="source">
        /// source
        /// </param>
        /// <returns>
        /// return queryable
        /// </returns>
        public static IQueryable Distinct(this IQueryable source)
        {
            var call = Expression.Call(typeof(Queryable), "Distinct", new[] { source.ElementType }, source.Expression);
            return source.Provider.CreateQuery(call);
        }

        /// <summary>
        /// The group by.
        /// </summary>
        /// <param name="source">
        /// The source.
        /// </param>
        /// <param name="keySelector">
        /// The key selector.
        /// </param>
        /// <param name="elementSelector">
        /// The element selector.
        /// </param>
        /// <param name="languageSupport">
        /// The current Culture Provider.
        /// </param>
        /// <param name="values">
        /// The values.
        /// </param>
        /// <returns>
        /// The <see cref="IQueryable"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// </exception>
        public static IQueryable GroupBy(
            this IQueryable source,
            string keySelector,
            string elementSelector,
            ILanguageSupport languageSupport,
            params object[] values)
        {
            if (source == null)
            {
                throw new ArgumentNullException("source");
            }

            if (keySelector == null)
            {
                throw new ArgumentNullException("keySelector");
            }

            if (elementSelector == null)
            {
                throw new ArgumentNullException("elementSelector");
            }

            LambdaExpression keyLambda = DynamicExpression.ParseLambda(source.ElementType, null, keySelector, languageSupport, values);
            LambdaExpression elementLambda = DynamicExpression.ParseLambda(
                source.ElementType,
                null,
                elementSelector,
                languageSupport,
                values);
            return
                source.Provider.CreateQuery(
                    Expression.Call(
                        typeof(Queryable),
                        "GroupBy",
                        new[] { source.ElementType, keyLambda.Body.Type, elementLambda.Body.Type },
                        source.Expression,
                        Expression.Quote(keyLambda),
                        Expression.Quote(elementLambda)));
        }

        /// <summary>
        /// The order by.
        /// </summary>
        /// <param name="source">
        /// The source.
        /// </param>
        /// <param name="ordering">
        /// The ordering.
        /// </param>
        /// <param name="languageSupport">
        /// current culture
        /// </param>
        /// <param name="values">
        /// The values.
        /// </param>
        /// <typeparam name="T">
        /// </typeparam>
        /// <returns>
        /// The <see cref="IQueryable"/>.
        /// </returns>
        public static IQueryable<T> OrderBy<T>(
            this IQueryable<T> source,
            string ordering,
            ILanguageSupport languageSupport,
            params object[] values)
        {
            return (IQueryable<T>)OrderBy((IQueryable)source, ordering, languageSupport, values);
        }

        /// <summary>
        /// The order by.
        /// </summary>
        /// <param name="source">
        /// The source.
        /// </param>
        /// <param name="ordering">
        /// The ordering.
        /// </param>
        /// <param name="languageSupport">
        /// </param>
        /// <param name="values">
        /// The values.
        /// </param>
        /// <returns>
        /// The <see cref="IQueryable"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// </exception>
        public static IQueryable OrderBy(this IQueryable source, string ordering, ILanguageSupport languageSupport, params object[] values)
        {
            if (source == null)
            {
                throw new ArgumentNullException("source");
            }

            if (ordering == null)
            {
                throw new ArgumentNullException("ordering");
            }

            var parameters = new[] { Expression.Parameter(source.ElementType, string.Empty) };
            var parser = new ExpressionParser(parameters, ordering, values, languageSupport);
            IEnumerable<DynamicOrdering> orderings = parser.ParseOrdering();
            Expression queryExpr = source.Expression;
            string methodAsc = "OrderBy";
            string methodDesc = "OrderByDescending";
            foreach (var o in orderings)
            {
                queryExpr = Expression.Call(
                    typeof(Queryable),
                    o.Ascending ? methodAsc : methodDesc,
                    new[] { source.ElementType, o.Selector.Type },
                    queryExpr,
                    Expression.Quote(Expression.Lambda(o.Selector, parameters)));
                methodAsc = "ThenBy";
                methodDesc = "ThenByDescending";
            }

            return source.Provider.CreateQuery(queryExpr);
        }

        /// <summary>
        /// The select.
        /// </summary>
        /// <param name="source">
        /// The source.
        /// </param>
        /// <param name="selector">
        /// The selector.
        /// </param>
        /// <param name="languageSupport">
        /// current cutlure
        /// </param>
        /// <param name="values">
        /// The values.
        /// </param>
        /// <returns>
        /// The <see cref="IQueryable"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// </exception>
        public static IQueryable Select(this IQueryable source, string selector, ILanguageSupport languageSupport, params object[] values)
        {
            if (source == null)
            {
                throw new ArgumentNullException("source");
            }

            if (selector == null)
            {
                throw new ArgumentNullException("selector");
            }

            LambdaExpression lambda = DynamicExpression.ParseLambda(source.ElementType, null, selector, languageSupport, values);
            return
                source.Provider.CreateQuery(
                    Expression.Call(
                        typeof(Queryable),
                        "Select",
                        new[] { source.ElementType, lambda.Body.Type },
                        source.Expression,
                        Expression.Quote(lambda)));
        }

        /// <summary>
        /// The skip.
        /// </summary>
        /// <param name="source">
        /// The source.
        /// </param>
        /// <param name="count">
        /// The count.
        /// </param>
        /// <returns>
        /// The <see cref="IQueryable"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// </exception>
        public static IQueryable Skip(this IQueryable source, int count)
        {
            if (source == null)
            {
                throw new ArgumentNullException("source");
            }

            return
                source.Provider.CreateQuery(
                    Expression.Call(typeof(Queryable), "Skip", new[] { source.ElementType }, source.Expression, Expression.Constant(count)));
        }

        /// <summary>
        /// The take.
        /// </summary>
        /// <param name="source">
        /// The source.
        /// </param>
        /// <param name="count">
        /// The count.
        /// </param>
        /// <returns>
        /// The <see cref="IQueryable"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// </exception>
        public static IQueryable Take(this IQueryable source, int count)
        {
            if (source == null)
            {
                throw new ArgumentNullException("source");
            }

            return
                source.Provider.CreateQuery(
                    Expression.Call(typeof(Queryable), "Take", new[] { source.ElementType }, source.Expression, Expression.Constant(count)));
        }

        /// <summary>
        /// The union.
        /// </summary>
        /// <param name="source">
        /// The source.
        /// </param>
        /// <param name="other">
        /// The other.
        /// </param>
        /// <returns>
        /// The <see cref="IQueryable"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// </exception>
        public static IQueryable Union(this IQueryable source, IQueryable other)
        {
            if (source == null)
            {
                throw new ArgumentNullException("source");
            }

            return
                source.Provider.CreateQuery(
                    Expression.Call(typeof(Queryable), "Union", new[] { source.ElementType }, source.Expression, other.Expression));
        }

        /// <summary>
        /// The where.
        /// </summary>
        /// <param name="source">
        /// The source.
        /// </param>
        /// <param name="predicate">
        /// The predicate.
        /// </param>
        /// <param name="languageSupport">
        /// current culture
        /// </param>
        /// <param name="values">
        /// The values.
        /// </param>
        /// <typeparam name="T">
        /// </typeparam>
        /// <returns>
        /// The <see cref="IQueryable"/>.
        /// </returns>
        public static IQueryable<T> Where<T>(
            this IQueryable<T> source,
            string predicate,
            ILanguageSupport languageSupport,
            params object[] values)
        {
            return (IQueryable<T>)Where((IQueryable)source, predicate, languageSupport, values);
        }

        /// <summary>
        /// The where.
        /// </summary>
        /// <param name="source">
        /// The source.
        /// </param>
        /// <param name="predicate">
        /// The predicate.
        /// </param>
        /// <param name="languageSupport">
        /// current culture
        /// </param>
        /// <param name="values">
        /// The values.
        /// </param>
        /// <returns>
        /// The <see cref="IQueryable"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// </exception>
        public static IQueryable Where(this IQueryable source, string predicate, ILanguageSupport languageSupport, params object[] values)
        {
            if (source == null)
            {
                throw new ArgumentNullException("source");
            }

            if (predicate == null)
            {
                throw new ArgumentNullException("predicate");
            }

            LambdaExpression lambda = DynamicExpression.ParseLambda(source.ElementType, typeof(bool), predicate, languageSupport, values);
            return
                source.Provider.CreateQuery(
                    Expression.Call(typeof(Queryable), "Where", new[] { source.ElementType }, source.Expression, Expression.Quote(lambda)));
        }

        /// <summary>
        /// The where.
        /// </summary>
        /// <param name="source">
        /// The source.
        /// </param>
        /// <param name="filter">
        /// The filter.
        /// </param>
        /// <returns>
        /// The <see cref="IQueryable"/>.
        /// </returns>
        public static IQueryable Where<T>(this IQueryable source, LambdaExpression filter)
        {
            if (source == null)
            {
                throw new ArgumentNullException("source");
            }

            if (filter == null)
            {
                return source;
            }

            return
                source.Provider.CreateQuery(
                    Expression.Call(typeof(Queryable), "Where", new[] { source.ElementType }, source.Expression, filter));
        }
    }

    /// <summary>
    ///     The dynamic class.
    /// </summary>
    [ExcludeFromCodeCoverage]
    public abstract class DynamicClass
    {
        /// <summary>
        ///     The to string.
        /// </summary>
        /// <returns>
        ///     The <see cref="string" />.
        /// </returns>
        public override string ToString()
        {
            PropertyInfo[] props = this.GetType().GetProperties(BindingFlags.Instance | BindingFlags.Public);
            var sb = new StringBuilder();
            sb.Append("{");
            for (int i = 0; i < props.Length; i++)
            {
                if (i > 0)
                {
                    sb.Append(", ");
                }

                sb.Append(props[i].Name);
                sb.Append("=");
                sb.Append(props[i].GetValue(this, null));
            }

            sb.Append("}");
            return sb.ToString();
        }
    }

    /// <summary>
    ///     The dynamic property.
    /// </summary>
    [ExcludeFromCodeCoverage]
    public class DynamicProperty
    {
        private readonly string name;

        private readonly Type type;

        /// <summary>
        /// Initializes a new instance of the <see cref="DynamicProperty"/> class.
        /// </summary>
        /// <param name="name">
        /// The name.
        /// </param>
        /// <param name="type">
        /// The type.
        /// </param>
        /// <exception cref="ArgumentNullException">
        /// </exception>
        public DynamicProperty(string name, Type type)
        {
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }

            if (type == null)
            {
                throw new ArgumentNullException("type");
            }

            this.name = name;
            this.type = type;
        }

        /// <summary>
        ///     Gets the name.
        /// </summary>
        public string Name
        {
            get
            {
                return this.name;
            }
        }

        /// <summary>
        ///     Gets the type.
        /// </summary>
        public Type Type
        {
            get
            {
                return this.type;
            }
        }
    }

    /// <summary>
    ///     The dynamic expression.
    /// </summary>
    [ExcludeFromCodeCoverage]
    public static class DynamicExpression
    {
        /// <summary>
        /// The create class.
        /// </summary>
        /// <param name="properties">
        /// The properties.
        /// </param>
        /// <returns>
        /// The <see cref="Type"/>.
        /// </returns>
        public static Type CreateClass(params DynamicProperty[] properties)
        {
            return ClassFactory.Instance.GetDynamicClass(properties);
        }

        /// <summary>
        /// The create class.
        /// </summary>
        /// <param name="properties">
        /// The properties.
        /// </param>
        /// <returns>
        /// The <see cref="Type"/>.
        /// </returns>
        public static Type CreateClass(IEnumerable<DynamicProperty> properties)
        {
            return ClassFactory.Instance.GetDynamicClass(properties);
        }

        /// <summary>
        /// The parse.
        /// </summary>
        /// <param name="resultType">
        /// The result type.
        /// </param>
        /// <param name="expression">
        /// The expression.
        /// </param>
        /// <param name="languageSupport">
        /// current culture
        /// </param>
        /// <param name="values">
        /// The values.
        /// </param>
        /// <returns>
        /// The <see cref="Expression"/>.
        /// </returns>
        public static Expression Parse(Type resultType, string expression, ILanguageSupport languageSupport, params object[] values)
        {
            var parser = new ExpressionParser(null, expression, values, languageSupport);
            return parser.Parse(resultType);
        }

        /// <summary>
        /// The parse lambda.
        /// </summary>
        /// <param name="itType">
        /// The it type.
        /// </param>
        /// <param name="resultType">
        /// The result type.
        /// </param>
        /// <param name="expression">
        /// The expression.
        /// </param>
        /// <param name="languageSupport">
        /// current culture
        /// </param>
        /// <param name="values">
        /// The values.
        /// </param>
        /// <returns>
        /// The <see cref="LambdaExpression"/>.
        /// </returns>
        public static LambdaExpression ParseLambda(
            Type itType,
            Type resultType,
            string expression,
            ILanguageSupport languageSupport,
            params object[] values)
        {
            return ParseLambda(new[] { Expression.Parameter(itType, string.Empty) }, resultType, expression, languageSupport, values);
        }

        /// <summary>
        /// The parse lambda.
        /// </summary>
        /// <param name="parameters">
        /// The parameters.
        /// </param>
        /// <param name="resultType">
        /// The result type.
        /// </param>
        /// <param name="expression">
        /// The expression.
        /// </param>
        /// <param name="languageSupport">
        /// The current Culture Provider.
        /// </param>
        /// <param name="values">
        /// The values.
        /// </param>
        /// <returns>
        /// The <see cref="LambdaExpression"/>.
        /// </returns>
        public static LambdaExpression ParseLambda(
            ParameterExpression[] parameters,
            Type resultType,
            string expression,
            ILanguageSupport languageSupport,
            params object[] values)
        {
            var parser = new ExpressionParser(parameters, expression, values, languageSupport);
            return Expression.Lambda(parser.Parse(resultType), parameters);
        }

        /// <summary>
        /// The parse lambda.
        /// </summary>
        /// <param name="expression">
        /// The expression.
        /// </param>
        /// <param name="languageSupport">
        /// current culture
        /// </param>
        /// <param name="values">
        /// The values.
        /// </param>
        /// <typeparam name="T">
        /// </typeparam>
        /// <typeparam name="S">
        /// </typeparam>
        /// <returns>
        /// The <see cref="Expression"/>.
        /// </returns>
        public static Expression<Func<T, S>> ParseLambda<T, S>(string expression, ILanguageSupport languageSupport, params object[] values)
        {
            return (Expression<Func<T, S>>)ParseLambda(typeof(T), typeof(S), expression, languageSupport, values);
        }
    }

    /// <summary>
    ///     The dynamic ordering.
    /// </summary>
    [ExcludeFromCodeCoverage]
    public class DynamicOrdering
    {
        public bool Ascending;

        public Expression Selector;
    }

    [ExcludeFromCodeCoverage]
    internal class Signature : IEquatable<Signature>
    {
        public int hashCode;

        public DynamicProperty[] properties;

        /// <summary>
        /// Initializes a new instance of the <see cref="Signature"/> class.
        /// </summary>
        /// <param name="properties">
        /// The properties.
        /// </param>
        public Signature(IEnumerable<DynamicProperty> properties)
        {
            this.properties = properties.ToArray();
            this.hashCode = 0;
            foreach (var p in properties)
            {
                this.hashCode ^= p.Name.GetHashCode() ^ p.Type.GetHashCode();
            }
        }

        /// <summary>
        /// The equals.
        /// </summary>
        /// <param name="other">
        /// The other.
        /// </param>
        /// <returns>
        /// The <see cref="bool"/>.
        /// </returns>
        public bool Equals(Signature other)
        {
            if (this.properties.Length != other.properties.Length)
            {
                return false;
            }

            for (int i = 0; i < this.properties.Length; i++)
            {
                if (this.properties[i].Name != other.properties[i].Name || this.properties[i].Type != other.properties[i].Type)
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// The equals.
        /// </summary>
        /// <param name="obj">
        /// The obj.
        /// </param>
        /// <returns>
        /// The <see cref="bool"/>.
        /// </returns>
        public override bool Equals(object obj)
        {
            return obj is Signature ? this.Equals((Signature)obj) : false;
        }

        /// <summary>
        ///     The get hash code.
        /// </summary>
        /// <returns>
        ///     The <see cref="int" />.
        /// </returns>
        public override int GetHashCode()
        {
            return this.hashCode;
        }
    }

    [ExcludeFromCodeCoverage]
    internal class ClassFactory
    {
        public static readonly ClassFactory Instance = new ClassFactory();

        private readonly ConcurrentDictionary<Signature, Type> classes;

        private readonly ModuleBuilder module;

        private readonly ReaderWriterLock rwLock;

        private int classCount;

        /// <summary>
        ///     Initializes static members of the <see cref="ClassFactory" /> class.
        /// </summary>
        static ClassFactory()
        {
        }

        private ClassFactory()
        {
            var name = new AssemblyName("DynamicClasses");
            AssemblyBuilder assembly = AppDomain.CurrentDomain.DefineDynamicAssembly(name, AssemblyBuilderAccess.Run);
#if ENABLE_LINQ_PARTIAL_TRUST
            new ReflectionPermission(PermissionState.Unrestricted).Assert();
#endif
            try
            {
                this.module = assembly.DefineDynamicModule("Module");
            }
            finally
            {
#if ENABLE_LINQ_PARTIAL_TRUST
                PermissionSet.RevertAssert();
#endif
            }

            this.classes = new ConcurrentDictionary<Signature, Type>();
            this.rwLock = new ReaderWriterLock();
        }

        /// <summary>
        /// The get dynamic class.
        /// </summary>
        /// <param name="properties">
        /// The properties.
        /// </param>
        /// <returns>
        /// The <see cref="Type"/>.
        /// </returns>
        public Type GetDynamicClass(IEnumerable<DynamicProperty> properties)
        {
            this.rwLock.AcquireReaderLock(Timeout.Infinite);
            try
            {
                var signature = new Signature(properties);
                Type type;
                if (!this.classes.TryGetValue(signature, out type))
                {
                    type = this.CreateDynamicClass(signature.properties);
                    this.classes.TryAdd(signature, type);
                }

                return type;
            }
            finally
            {
                this.rwLock.ReleaseReaderLock();
            }
        }

        private Type CreateDynamicClass(DynamicProperty[] properties)
        {
            LockCookie cookie = this.rwLock.UpgradeToWriterLock(Timeout.Infinite);
            try
            {
                string typeName = "DynamicClass" + (this.classCount + 1);
#if ENABLE_LINQ_PARTIAL_TRUST
                new ReflectionPermission(PermissionState.Unrestricted).Assert();
#endif
                try
                {
                    TypeBuilder tb = this.module.DefineType(typeName, TypeAttributes.Class | TypeAttributes.Public, typeof(DynamicClass));
                    FieldInfo[] fields = this.GenerateProperties(tb, properties);
                    this.GenerateEquals(tb, fields);
                    this.GenerateGetHashCode(tb, fields);
                    Type result = tb.CreateType();
                    this.classCount++;
                    return result;
                }
                finally
                {
#if ENABLE_LINQ_PARTIAL_TRUST
                    PermissionSet.RevertAssert();
#endif
                }
            }
            finally
            {
                this.rwLock.DowngradeFromWriterLock(ref cookie);
            }
        }

        private void GenerateEquals(TypeBuilder tb, FieldInfo[] fields)
        {
            MethodBuilder mb = tb.DefineMethod(
                "Equals",
                MethodAttributes.Public | MethodAttributes.ReuseSlot | MethodAttributes.Virtual | MethodAttributes.HideBySig,
                typeof(bool),
                new[] { typeof(object) });
            ILGenerator gen = mb.GetILGenerator();
            LocalBuilder other = gen.DeclareLocal(tb);
            Label next = gen.DefineLabel();
            gen.Emit(OpCodes.Ldarg_1);
            gen.Emit(OpCodes.Isinst, tb);
            gen.Emit(OpCodes.Stloc, other);
            gen.Emit(OpCodes.Ldloc, other);
            gen.Emit(OpCodes.Brtrue_S, next);
            gen.Emit(OpCodes.Ldc_I4_0);
            gen.Emit(OpCodes.Ret);
            gen.MarkLabel(next);
            foreach (var field in fields)
            {
                Type ft = field.FieldType;
                Type ct = typeof(EqualityComparer<>).MakeGenericType(ft);
                next = gen.DefineLabel();
                gen.EmitCall(OpCodes.Call, ct.GetMethod("get_Default"), null);
                gen.Emit(OpCodes.Ldarg_0);
                gen.Emit(OpCodes.Ldfld, field);
                gen.Emit(OpCodes.Ldloc, other);
                gen.Emit(OpCodes.Ldfld, field);
                gen.EmitCall(OpCodes.Callvirt, ct.GetMethod("Equals", new[] { ft, ft }), null);
                gen.Emit(OpCodes.Brtrue_S, next);
                gen.Emit(OpCodes.Ldc_I4_0);
                gen.Emit(OpCodes.Ret);
                gen.MarkLabel(next);
            }

            gen.Emit(OpCodes.Ldc_I4_1);
            gen.Emit(OpCodes.Ret);
        }

        private void GenerateGetHashCode(TypeBuilder tb, FieldInfo[] fields)
        {
            MethodBuilder mb = tb.DefineMethod(
                "GetHashCode",
                MethodAttributes.Public | MethodAttributes.ReuseSlot | MethodAttributes.Virtual | MethodAttributes.HideBySig,
                typeof(int),
                Type.EmptyTypes);
            ILGenerator gen = mb.GetILGenerator();
            gen.Emit(OpCodes.Ldc_I4_0);
            foreach (var field in fields)
            {
                Type ft = field.FieldType;
                Type ct = typeof(EqualityComparer<>).MakeGenericType(ft);
                gen.EmitCall(OpCodes.Call, ct.GetMethod("get_Default"), null);
                gen.Emit(OpCodes.Ldarg_0);
                gen.Emit(OpCodes.Ldfld, field);
                gen.EmitCall(OpCodes.Callvirt, ct.GetMethod("GetHashCode", new[] { ft }), null);
                gen.Emit(OpCodes.Xor);
            }

            gen.Emit(OpCodes.Ret);
        }

        private FieldInfo[] GenerateProperties(TypeBuilder tb, DynamicProperty[] properties)
        {
            FieldInfo[] fields = new FieldBuilder[properties.Length];
            for (int i = 0; i < properties.Length; i++)
            {
                DynamicProperty dp = properties[i];
                FieldBuilder fb = tb.DefineField("_" + dp.Name, dp.Type, FieldAttributes.Private);
                PropertyBuilder pb = tb.DefineProperty(dp.Name, PropertyAttributes.HasDefault, dp.Type, null);
                MethodBuilder mbGet = tb.DefineMethod(
                    "get_" + dp.Name,
                    MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig,
                    dp.Type,
                    Type.EmptyTypes);
                ILGenerator genGet = mbGet.GetILGenerator();
                genGet.Emit(OpCodes.Ldarg_0);
                genGet.Emit(OpCodes.Ldfld, fb);
                genGet.Emit(OpCodes.Ret);
                MethodBuilder mbSet = tb.DefineMethod(
                    "set_" + dp.Name,
                    MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig,
                    null,
                    new[] { dp.Type });
                ILGenerator genSet = mbSet.GetILGenerator();
                genSet.Emit(OpCodes.Ldarg_0);
                genSet.Emit(OpCodes.Ldarg_1);
                genSet.Emit(OpCodes.Stfld, fb);
                genSet.Emit(OpCodes.Ret);
                pb.SetGetMethod(mbGet);
                pb.SetSetMethod(mbSet);
                fields[i] = fb;
            }

            return fields;
        }
    }

    /// <summary>
    ///     The parse exception.
    /// </summary>
    [ExcludeFromCodeCoverage]
    public sealed class ParseException : Exception
    {
        private readonly int position;

        /// <summary>
        /// Initializes a new instance of the <see cref="ParseException"/> class.
        /// </summary>
        /// <param name="message">
        /// The message.
        /// </param>
        /// <param name="position">
        /// The position.
        /// </param>
        public ParseException(string message, int position)
            : base(message)
        {
            this.position = position;
        }

        /// <summary>
        ///     Gets the position.
        /// </summary>
        public int Position
        {
            get
            {
                return this.position;
            }
        }

        /// <summary>
        ///     The to string.
        /// </summary>
        /// <returns>
        ///     The <see cref="string" />.
        /// </returns>
        public override string ToString()
        {
            return string.Format(Res.ParseExceptionFormat, this.Message, this.position);
        }
    }

    [ExcludeFromCodeCoverage]
    internal class ExpressionParser
    {
        private static readonly Expression falseLiteral = Expression.Constant(false);

        private static readonly string keywordIif = "iif";

        private static readonly string keywordIt = "it";

        private static readonly string keywordNew = "new";

        private static readonly Expression nullLiteral = Expression.Constant(null);

        private static readonly Type[] predefinedTypes =
            {
                typeof(Object), typeof(Boolean), typeof(Char), typeof(String), typeof(SByte),
                typeof(Byte), typeof(Int16), typeof(UInt16), typeof(Int32), typeof(UInt32),
                typeof(Int64), typeof(UInt64), typeof(Single), typeof(Double), typeof(Decimal),
                typeof(DateTime), typeof(TimeSpan), typeof(Guid), typeof(Math), typeof(Convert),
                typeof(System.Data.Entity.DbFunctions)
            };

        private static readonly Expression trueLiteral = Expression.Constant(true);

        private static Dictionary<string, object> keywords;

        private readonly IDictionary<string, object> internals = new Dictionary<string, object>();

        private readonly ILanguageSupport languageSupport;

        private readonly Dictionary<Expression, string> literals;

        private readonly Dictionary<string, object> symbols;

        private readonly string text;

        private readonly int textLen;

        private char ch;

        private IDictionary<string, object> externals;

        private ParameterExpression it;

        private int textPos;

        private Token token;

        /// <summary>
        /// Initializes a new instance of the <see cref="ExpressionParser"/> class.
        /// </summary>
        /// <param name="parameters">
        /// The parameters.
        /// </param>
        /// <param name="expression">
        /// The expression.
        /// </param>
        /// <param name="values">
        /// The values.
        /// </param>
        /// <param name="languageSupport">
        /// </param>
        /// <exception cref="ArgumentNullException">
        /// </exception>
        public ExpressionParser(ParameterExpression[] parameters, string expression, object[] values, ILanguageSupport languageSupport)
        {
            if (expression == null)
            {
                throw new ArgumentNullException("expression");
            }

            if (keywords == null)
            {
                keywords = CreateKeywords();
            }

            this.symbols = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);
            this.literals = new Dictionary<Expression, string>();
            if (parameters != null)
            {
                this.ProcessParameters(parameters);
            }

            if (values != null)
            {
                this.ProcessValues(values);
            }

            if (languageSupport == null)
            {
                //throw new ArgumentNullException("languageSupport");
            }

            this.text = expression;
            this.languageSupport = languageSupport;
            this.textLen = this.text.Length;
            this.SetTextPos(0);
            this.NextToken();
        }

        private enum TokenId
        {
            /// <summary>
            ///     The unknown.
            /// </summary>
            Unknown,

            /// <summary>
            ///     The end.
            /// </summary>
            End,

            /// <summary>
            ///     The identifier.
            /// </summary>
            Identifier,

            /// <summary>
            ///     The string literal.
            /// </summary>
            StringLiteral,

            /// <summary>
            ///     The integer literal.
            /// </summary>
            IntegerLiteral,

            /// <summary>
            ///     The real literal.
            /// </summary>
            RealLiteral,

            /// <summary>
            ///     The exclamation.
            /// </summary>
            Exclamation,

            /// <summary>
            ///     The percent.
            /// </summary>
            Percent,

            /// <summary>
            ///     The amphersand.
            /// </summary>
            Amphersand,

            /// <summary>
            ///     The open paren.
            /// </summary>
            OpenParen,

            /// <summary>
            ///     The close paren.
            /// </summary>
            CloseParen,

            /// <summary>
            ///     The asterisk.
            /// </summary>
            Asterisk,

            /// <summary>
            ///     The plus.
            /// </summary>
            Plus,

            /// <summary>
            ///     The comma.
            /// </summary>
            Comma,

            /// <summary>
            ///     The minus.
            /// </summary>
            Minus,

            /// <summary>
            ///     The dot.
            /// </summary>
            Dot,

            /// <summary>
            ///     The slash.
            /// </summary>
            Slash,

            /// <summary>
            ///     The colon.
            /// </summary>
            Colon,

            /// <summary>
            ///     The less than.
            /// </summary>
            LessThan,

            /// <summary>
            ///     The equal.
            /// </summary>
            Equal,

            /// <summary>
            ///     The greater than.
            /// </summary>
            GreaterThan,

            /// <summary>
            ///     The question.
            /// </summary>
            Question,

            /// <summary>
            ///     The open bracket.
            /// </summary>
            OpenBracket,

            /// <summary>
            ///     The close bracket.
            /// </summary>
            CloseBracket,

            /// <summary>
            ///     The bar.
            /// </summary>
            Bar,

            /// <summary>
            ///     The exclamation equal.
            /// </summary>
            ExclamationEqual,

            /// <summary>
            ///     The double amphersand.
            /// </summary>
            DoubleAmphersand,

            /// <summary>
            ///     The less than equal.
            /// </summary>
            LessThanEqual,

            /// <summary>
            ///     The less greater.
            /// </summary>
            LessGreater,

            /// <summary>
            ///     The double equal.
            /// </summary>
            DoubleEqual,

            /// <summary>
            ///     The greater than equal.
            /// </summary>
            GreaterThanEqual,

            /// <summary>
            ///     The double bar.
            /// </summary>
            DoubleBar,

            /// <summary>
            ///     The lambda.
            /// </summary>
            Lambda
        }

        private interface IAddSignatures : IArithmeticSignatures
        {
            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(DateTime x, TimeSpan y);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(TimeSpan x, TimeSpan y);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(DateTime? x, TimeSpan? y);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(TimeSpan? x, TimeSpan? y);
        }

        private interface IArithmeticSignatures
        {
            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(int x, int y);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(uint x, uint y);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(long x, long y);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(ulong x, ulong y);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(float x, float y);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(double x, double y);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(decimal x, decimal y);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(int? x, int? y);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(uint? x, uint? y);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(long? x, long? y);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(ulong? x, ulong? y);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(float? x, float? y);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(double? x, double? y);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(decimal? x, decimal? y);
        }

        private interface IEnumerableSignatures
        {
            /// <summary>
            /// The all.
            /// </summary>
            /// <param name="predicate">
            /// The predicate.
            /// </param>
            void All(bool predicate);

            /// <summary>
            ///     The any.
            /// </summary>
            void Any();

            /// <summary>
            /// The any.
            /// </summary>
            /// <param name="predicate">
            /// The predicate.
            /// </param>
            void Any(bool predicate);

            /// <summary>
            /// The average.
            /// </summary>
            /// <param name="selector">
            /// The selector.
            /// </param>
            void Average(int selector);

            /// <summary>
            /// The average.
            /// </summary>
            /// <param name="selector">
            /// The selector.
            /// </param>
            void Average(int? selector);

            /// <summary>
            /// The average.
            /// </summary>
            /// <param name="selector">
            /// The selector.
            /// </param>
            void Average(long selector);

            /// <summary>
            /// The average.
            /// </summary>
            /// <param name="selector">
            /// The selector.
            /// </param>
            void Average(long? selector);

            /// <summary>
            /// The average.
            /// </summary>
            /// <param name="selector">
            /// The selector.
            /// </param>
            void Average(float selector);

            /// <summary>
            /// The average.
            /// </summary>
            /// <param name="selector">
            /// The selector.
            /// </param>
            void Average(float? selector);

            /// <summary>
            /// The average.
            /// </summary>
            /// <param name="selector">
            /// The selector.
            /// </param>
            void Average(double selector);

            /// <summary>
            /// The average.
            /// </summary>
            /// <param name="selector">
            /// The selector.
            /// </param>
            void Average(double? selector);

            /// <summary>
            /// The average.
            /// </summary>
            /// <param name="selector">
            /// The selector.
            /// </param>
            void Average(decimal selector);

            /// <summary>
            /// The average.
            /// </summary>
            /// <param name="selector">
            /// The selector.
            /// </param>
            void Average(decimal? selector);

            /// <summary>
            ///     The count.
            /// </summary>
            void Count();

            /// <summary>
            /// The count.
            /// </summary>
            /// <param name="predicate">
            /// The predicate.
            /// </param>
            void Count(bool predicate);

            /// <summary>
            /// The max.
            /// </summary>
            /// <param name="selector">
            /// The selector.
            /// </param>
            void Max(object selector);

            /// <summary>
            /// The min.
            /// </summary>
            /// <param name="selector">
            /// The selector.
            /// </param>
            void Min(object selector);

            /// <summary>
            /// The order by.
            /// </summary>
            /// <param name="exp">
            /// The exp.
            /// </param>
            void OrderBy(LambdaExpression exp);

            /// <summary>
            /// The order by descending.
            /// </summary>
            /// <param name="exp">
            /// The exp.
            /// </param>
            void OrderByDescending(LambdaExpression exp);

            /// <summary>
            /// The sum.
            /// </summary>
            /// <param name="selector">
            /// The selector.
            /// </param>
            void Sum(int selector);

            /// <summary>
            /// The sum.
            /// </summary>
            /// <param name="selector">
            /// The selector.
            /// </param>
            void Sum(int? selector);

            /// <summary>
            /// The sum.
            /// </summary>
            /// <param name="selector">
            /// The selector.
            /// </param>
            void Sum(long selector);

            /// <summary>
            /// The sum.
            /// </summary>
            /// <param name="selector">
            /// The selector.
            /// </param>
            void Sum(long? selector);

            /// <summary>
            /// The sum.
            /// </summary>
            /// <param name="selector">
            /// The selector.
            /// </param>
            void Sum(float selector);

            /// <summary>
            /// The sum.
            /// </summary>
            /// <param name="selector">
            /// The selector.
            /// </param>
            void Sum(float? selector);

            /// <summary>
            /// The sum.
            /// </summary>
            /// <param name="selector">
            /// The selector.
            /// </param>
            void Sum(double selector);

            /// <summary>
            /// The sum.
            /// </summary>
            /// <param name="selector">
            /// The selector.
            /// </param>
            void Sum(double? selector);

            /// <summary>
            /// The sum.
            /// </summary>
            /// <param name="selector">
            /// The selector.
            /// </param>
            void Sum(decimal selector);

            /// <summary>
            /// The sum.
            /// </summary>
            /// <param name="selector">
            /// The selector.
            /// </param>
            void Sum(decimal? selector);

            /// <summary>
            /// The take.
            /// </summary>
            /// <param name="count">
            /// The count.
            /// </param>
            void Take(int count);

            /// <summary>
            /// The union.
            /// </summary>
            /// <param name="right">
            /// The right.
            /// </param>
            void Union(IQueryable right);

            /// <summary>
            /// The where.
            /// </summary>
            /// <param name="predicate">
            /// The predicate.
            /// </param>
            void Where(bool predicate);
        }

        private interface IEqualitySignatures : IRelationalSignatures
        {
            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(bool x, bool y);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(bool? x, bool? y);

            /// <summary>
            /// Fs the specified x.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(Guid x, Guid y);

            /// <summary>
            /// Fs the specified x.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(Guid? x, Guid? y);
        }

        private interface ILogicalSignatures
        {
            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(bool x, bool y);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(bool? x, bool? y);
        }

        private interface INegationSignatures
        {
            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            void F(int x);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            void F(long x);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            void F(float x);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            void F(double x);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            void F(decimal x);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            void F(int? x);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            void F(long? x);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            void F(float? x);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            void F(double? x);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            void F(decimal? x);
        }

        private interface INotSignatures
        {
            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            void F(bool x);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            void F(bool? x);
        }

        private interface IRelationalSignatures : IArithmeticSignatures
        {
            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(string x, string y);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(char x, char y);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(DateTime x, DateTime y);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(TimeSpan x, TimeSpan y);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(char? x, char? y);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(DateTime? x, DateTime? y);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(TimeSpan? x, TimeSpan? y);

            /// <summary>
            /// Fs the specified x.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(DateTime? x, object y);
        }

        private interface ISubtractSignatures : IAddSignatures
        {
            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(DateTime x, DateTime y);

            /// <summary>
            /// The f.
            /// </summary>
            /// <param name="x">
            /// The x.
            /// </param>
            /// <param name="y">
            /// The y.
            /// </param>
            void F(DateTime? x, DateTime? y);
        }

        /// <summary>
        /// The parse.
        /// </summary>
        /// <param name="resultType">
        /// The result type.
        /// </param>
        /// <returns>
        /// The <see cref="Expression"/>.
        /// </returns>
        /// <exception cref="Exception">
        /// </exception>
        public Expression Parse(Type resultType)
        {
            int exprPos = this.token.pos;
            Expression expr = this.ParseExpression();
            if (resultType != null)
            {
                if ((expr = this.PromoteExpression(expr, resultType, true)) == null)
                {
                    throw this.ParseError(exprPos, Res.ExpressionTypeMismatch, GetTypeName(resultType));
                }
            }

            this.ValidateToken(TokenId.End, Res.SyntaxError);
            return expr;
        }

#pragma warning disable 0219

        /// <summary>
        ///     The parse ordering.
        /// </summary>
        /// <returns>
        ///     The <see cref="IEnumerable" />.
        /// </returns>
        public IEnumerable<DynamicOrdering> ParseOrdering()
        {
            var orderings = new List<DynamicOrdering>();
            while (true)
            {
                Expression expr = this.ParseExpression();
                bool ascending = true;
                if (this.TokenIdentifierIs("asc") || this.TokenIdentifierIs("ascending"))
                {
                    this.NextToken();
                }
                else if (this.TokenIdentifierIs("desc") || this.TokenIdentifierIs("descending"))
                {
                    this.NextToken();
                    ascending = false;
                }

                orderings.Add(new DynamicOrdering { Selector = expr, Ascending = ascending });
                if (this.token.id != TokenId.Comma)
                {
                    break;
                }

                this.NextToken();
            }

            this.ValidateToken(TokenId.End, Res.SyntaxError);
            return orderings;
        }

#pragma warning restore 0219

        private static void AddInterface(List<Type> types, Type type)
        {
            if (!types.Contains(type))
            {
                types.Add(type);
                foreach (var t in type.GetInterfaces())
                {
                    AddInterface(types, t);
                }
            }
        }

        // Return 1 if s -> t1 is a better conversion than s -> t2
        // Return -1 if s -> t2 is a better conversion than s -> t1
        // Return 0 if neither conversion is better
        private static int CompareConversions(Type s, Type t1, Type t2)
        {
            if (t1 == t2)
            {
                return 0;
            }

            if (s == t1)
            {
                return 1;
            }

            if (s == t2)
            {
                return -1;
            }

            bool t1t2 = IsCompatibleWith(t1, t2);
            bool t2t1 = IsCompatibleWith(t2, t1);
            if (t1t2 && !t2t1)
            {
                return 1;
            }

            if (t2t1 && !t1t2)
            {
                return -1;
            }

            if (IsSignedIntegralType(t1) && IsUnsignedIntegralType(t2))
            {
                return 1;
            }

            if (IsSignedIntegralType(t2) && IsUnsignedIntegralType(t1))
            {
                return -1;
            }

            return 0;
        }

        private static Dictionary<string, object> CreateKeywords()
        {
            var d = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);
            d.Add("true", trueLiteral);
            d.Add("false", falseLiteral);
            d.Add("null", nullLiteral);
            d.Add(keywordIt, keywordIt);
            d.Add(keywordIif, keywordIif);
            d.Add(keywordNew, keywordNew);
            foreach (var type in predefinedTypes)
            {
                d.Add(type.Name, type);
            }

            return d;
        }

        private static Type FindGenericType(Type generic, Type type)
        {
            while (type != null && type != typeof(object))
            {
                if (type.IsGenericType && type.GetGenericTypeDefinition() == generic)
                {
                    return type;
                }

                if (generic.IsInterface)
                {
                    foreach (var intfType in type.GetInterfaces())
                    {
                        Type found = FindGenericType(generic, intfType);
                        if (found != null)
                        {
                            return found;
                        }
                    }
                }

                type = type.BaseType;
            }

            return null;
        }

        private static Type GetNonNullableType(Type type)
        {
            return IsNullableType(type) ? type.GetGenericArguments()[0] : type;
        }

        private static int GetNumericTypeKind(Type type)
        {
            type = GetNonNullableType(type);
            if (type.IsEnum)
            {
                return 0;
            }

            switch (Type.GetTypeCode(type))
            {
                case TypeCode.Char:
                case TypeCode.Single:
                case TypeCode.Double:
                case TypeCode.Decimal:
                    return 1;
                case TypeCode.SByte:
                case TypeCode.Int16:
                case TypeCode.Int32:
                case TypeCode.Int64:
                    return 2;
                case TypeCode.Byte:
                case TypeCode.UInt16:
                case TypeCode.UInt32:
                case TypeCode.UInt64:
                    return 3;
                default:
                    return 0;
            }
        }

        private static string GetTypeName(Type type)
        {
            Type baseType = GetNonNullableType(type);
            string s = baseType.Name;
            if (type != baseType)
            {
                s += '?';
            }

            return s;
        }

        private static bool IsBetterThan(Expression[] args, MethodData m1, MethodData m2)
        {
            bool better = false;
            for (int i = 0; i < args.Length; i++)
            {
                int c = CompareConversions(args[i].Type, m1.Parameters[i].ParameterType, m2.Parameters[i].ParameterType);
                if (c < 0)
                {
                    return false;
                }

                if (c > 0)
                {
                    better = true;
                }
            }

            return better;
        }

        private static bool IsCompatibleWith(Type source, Type target)
        {
            if (source == target)
            {
                return true;
            }

            if (!target.IsValueType)
            {
                return target.IsAssignableFrom(source);
            }

            Type st = GetNonNullableType(source);
            Type tt = GetNonNullableType(target);
            if (st != source && tt == target)
            {
                return false;
            }

            TypeCode sc = st.IsEnum ? TypeCode.Object : Type.GetTypeCode(st);
            TypeCode tc = tt.IsEnum ? TypeCode.Object : Type.GetTypeCode(tt);
            switch (sc)
            {
                case TypeCode.SByte:
                    switch (tc)
                    {
                        case TypeCode.SByte:
                        case TypeCode.Int16:
                        case TypeCode.Int32:
                        case TypeCode.Int64:
                        case TypeCode.Single:
                        case TypeCode.Double:
                        case TypeCode.Decimal:
                            return true;
                    }

                    break;
                case TypeCode.Byte:
                    switch (tc)
                    {
                        case TypeCode.Byte:
                        case TypeCode.Int16:
                        case TypeCode.UInt16:
                        case TypeCode.Int32:
                        case TypeCode.UInt32:
                        case TypeCode.Int64:
                        case TypeCode.UInt64:
                        case TypeCode.Single:
                        case TypeCode.Double:
                        case TypeCode.Decimal:
                            return true;
                    }

                    break;
                case TypeCode.Int16:
                    switch (tc)
                    {
                        case TypeCode.Int16:
                        case TypeCode.Int32:
                        case TypeCode.Int64:
                        case TypeCode.Single:
                        case TypeCode.Double:
                        case TypeCode.Decimal:
                            return true;
                    }

                    break;
                case TypeCode.UInt16:
                    switch (tc)
                    {
                        case TypeCode.UInt16:
                        case TypeCode.Int32:
                        case TypeCode.UInt32:
                        case TypeCode.Int64:
                        case TypeCode.UInt64:
                        case TypeCode.Single:
                        case TypeCode.Double:
                        case TypeCode.Decimal:
                            return true;
                    }

                    break;
                case TypeCode.Int32:
                    switch (tc)
                    {
                        case TypeCode.Int32:
                        case TypeCode.Int64:
                        case TypeCode.Single:
                        case TypeCode.Double:
                        case TypeCode.Decimal:
                            return true;
                    }

                    break;
                case TypeCode.UInt32:
                    switch (tc)
                    {
                        case TypeCode.UInt32:
                        case TypeCode.Int64:
                        case TypeCode.UInt64:
                        case TypeCode.Single:
                        case TypeCode.Double:
                        case TypeCode.Decimal:
                            return true;
                    }

                    break;
                case TypeCode.Int64:
                    switch (tc)
                    {
                        case TypeCode.Int64:
                        case TypeCode.Single:
                        case TypeCode.Double:
                        case TypeCode.Decimal:
                            return true;
                    }

                    break;
                case TypeCode.UInt64:
                    switch (tc)
                    {
                        case TypeCode.UInt64:
                        case TypeCode.Single:
                        case TypeCode.Double:
                        case TypeCode.Decimal:
                            return true;
                    }

                    break;
                case TypeCode.Single:
                    switch (tc)
                    {
                        case TypeCode.Single:
                        case TypeCode.Double:
                            return true;
                    }

                    break;
                default:
                    if (st == tt)
                    {
                        return true;
                    }

                    break;
            }

            return false;
        }

        private static bool IsEnumType(Type type)
        {
            return GetNonNullableType(type).IsEnum;
        }

        private static bool IsNullableType(Type type)
        {
            return type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>);
        }

        private static bool IsNumericType(Type type)
        {
            return GetNumericTypeKind(type) != 0;
        }

        private static bool IsPredefinedType(Type type)
        {
            foreach (var t in predefinedTypes)
            {
                if (t == type)
                {
                    return true;
                }
            }

            return false;
        }

        private static bool IsSignedIntegralType(Type type)
        {
            return GetNumericTypeKind(type) == 2;
        }

        private static bool IsUnsignedIntegralType(Type type)
        {
            return GetNumericTypeKind(type) == 3;
        }

        private static object ParseEnum(string name, Type type)
        {
            if (type.IsEnum)
            {
                MemberInfo[] memberInfos = type.FindMembers(
                    MemberTypes.Field,
                    BindingFlags.Public | BindingFlags.DeclaredOnly | BindingFlags.Static,
                    Type.FilterNameIgnoreCase,
                    name);
                if (memberInfos.Length != 0)
                {
                    return ((FieldInfo)memberInfos[0]).GetValue(null);
                }
            }

            return null;
        }

        private static object ParseNumber(string text, Type type)
        {
            switch (Type.GetTypeCode(GetNonNullableType(type)))
            {
                case TypeCode.SByte:
                    sbyte sb;
                    if (sbyte.TryParse(text, out sb))
                    {
                        return sb;
                    }

                    break;
                case TypeCode.Byte:
                    byte b;
                    if (byte.TryParse(text, out b))
                    {
                        return b;
                    }

                    break;
                case TypeCode.Int16:
                    short s;
                    if (short.TryParse(text, out s))
                    {
                        return s;
                    }

                    break;
                case TypeCode.UInt16:
                    ushort us;
                    if (ushort.TryParse(text, out us))
                    {
                        return us;
                    }

                    break;
                case TypeCode.Int32:
                    int i;
                    if (int.TryParse(text, out i))
                    {
                        return i;
                    }

                    break;
                case TypeCode.UInt32:
                    uint ui;
                    if (uint.TryParse(text, out ui))
                    {
                        return ui;
                    }

                    break;
                case TypeCode.Int64:
                    long l;
                    if (long.TryParse(text, out l))
                    {
                        return l;
                    }

                    break;
                case TypeCode.UInt64:
                    ulong ul;
                    if (ulong.TryParse(text, out ul))
                    {
                        return ul;
                    }

                    break;
                case TypeCode.Single:
                    float f;
                    if (float.TryParse(text, out f))
                    {
                        return f;
                    }

                    break;
                case TypeCode.Double:
                    double d;
                    if (double.TryParse(text, out d))
                    {
                        return d;
                    }

                    break;
                case TypeCode.Decimal:
                    decimal e;
                    if (decimal.TryParse(text, out e))
                    {
                        return e;
                    }

                    break;
            }

            return null;
        }

        private static IEnumerable<Type> SelfAndBaseClasses(Type type)
        {
            while (type != null)
            {
                yield return type;
                type = type.BaseType;
            }
        }

        private static IEnumerable<Type> SelfAndBaseTypes(Type type)
        {
            if (type.IsInterface)
            {
                var types = new List<Type>();
                AddInterface(types, type);
                return types;
            }

            return SelfAndBaseClasses(type);
        }

        private void AddSymbol(string name, object value)
        {
            if (this.symbols.ContainsKey(name))
            {
                throw this.ParseError(Res.DuplicateIdentifier, name);
            }

            this.symbols.Add(name, value);
        }

        private void CheckAndPromoteOperand(Type signatures, string opName, ref Expression expr, int errorPos)
        {
            var args = new[] { expr };
            MethodBase method;
            if (this.FindMethod(signatures, "F", false, args, out method) != 1)
            {
                throw this.ParseError(errorPos, Res.IncompatibleOperand, opName, GetTypeName(args[0].Type));
            }

            expr = args[0];
        }

        private void CheckAndPromoteOperands(Type signatures, string opName, ref Expression left, ref Expression right, int errorPos)
        {
            var args = new[] { left, right };
            MethodBase method;
            if (this.FindMethod(signatures, "F", false, args, out method) != 1)
            {
                throw this.IncompatibleOperandsError(opName, left, right, errorPos);
            }

            left = args[0];
            right = args[1];
        }

        private Expression CreateLiteral(object value, string text)
        {
            ConstantExpression expr = Expression.Constant(value);
            this.literals.Add(expr, text);
            return expr;
        }

        private int FindBestMethod(IEnumerable<MethodBase> methods, Expression[] args, out MethodBase method)
        {
            MethodData[] applicable =
                methods.Select(
                    m =>
                    new MethodData
                        {
                            MethodBase = m,
                            Parameters = m.GetParameters() //.Where(p => p.ParameterType != ((MethodInfo)m).ReturnType).ToArray()
                        }).Where(m => this.IsApplicable(m, args)).ToArray();
            if (applicable.Length > 1)
            {
                applicable = applicable.Where(m => applicable.All(n => m == n || IsBetterThan(args, m, n))).ToArray();
            }

            if (applicable.Length == 1)
            {
                MethodData md = applicable[0];
                for (int i = 0; i < args.Length; i++)
                {
                    args[i] = md.Args[i];
                }

                method = md.MethodBase;
            }
            else
            {
                method = null;
            }

            return applicable.Length;
        }

        private int FindIndexer(Type type, Expression[] args, out MethodBase method)
        {
            foreach (var t in SelfAndBaseTypes(type))
            {
                MemberInfo[] members = t.GetDefaultMembers();
                if (members.Length != 0)
                {
                    IEnumerable<MethodBase> methods =
                        members.OfType<PropertyInfo>().Select(p => (MethodBase)p.GetGetMethod()).Where(m => m != null);
                    int count = this.FindBestMethod(methods, args, out method);
                    if (count != 0)
                    {
                        return count;
                    }
                }
            }

            method = null;
            return 0;
        }

        private int FindMethod(Type type, string methodName, bool staticAccess, Expression[] args, out MethodBase method)
        {
            BindingFlags flags = BindingFlags.Public | BindingFlags.DeclaredOnly
                                 | (staticAccess ? BindingFlags.Static : BindingFlags.Instance);
            foreach (var t in SelfAndBaseTypes(type))
            {
                MemberInfo[] members = t.FindMembers(MemberTypes.Method, flags, Type.FilterNameIgnoreCase, methodName).ToArray();
                //GetExtensionMethods
                int count = this.FindBestMethod(members.Cast<MethodBase>(), args, out method);
                if (count != 0)
                {
                    return count;
                }
            }

            method = null;
            return 0;
        }

        private MemberInfo FindPropertyOrField(Type type, string memberName, bool staticAccess)
        {
            BindingFlags flags = BindingFlags.Public | BindingFlags.DeclaredOnly
                                 | (staticAccess ? BindingFlags.Static : BindingFlags.Instance);
            foreach (var t in SelfAndBaseTypes(type))
            {
                MemberInfo[] members = t.FindMembers(MemberTypes.Property | MemberTypes.Field, flags, Type.FilterNameIgnoreCase, memberName);
                if (members.Length != 0)
                {
                    return members[0];
                }
            }

            return null;
        }

        private Expression GenerateAdd(Expression left, Expression right)
        {
            if (left.Type == typeof(string) && right.Type == typeof(string))
            {
                return this.GenerateStaticMethodCall("Concat", left, right);
            }

            return Expression.Add(left, right);
        }

        private Expression GenerateConditional(Expression test, Expression expr1, Expression expr2, int errorPos)
        {
            if (test.Type != typeof(bool))
            {
                throw this.ParseError(errorPos, Res.FirstExprMustBeBool);
            }

            if (expr1.Type != expr2.Type)
            {
                Expression expr1as2 = expr2 != nullLiteral ? this.PromoteExpression(expr1, expr2.Type, true) : null;
                Expression expr2as1 = expr1 != nullLiteral ? this.PromoteExpression(expr2, expr1.Type, true) : null;
                if (expr1as2 != null && expr2as1 == null)
                {
                    expr1 = expr1as2;
                }
                else if (expr2as1 != null && expr1as2 == null)
                {
                    expr2 = expr2as1;
                }
                else
                {
                    string type1 = expr1 != nullLiteral ? expr1.Type.Name : "null";
                    string type2 = expr2 != nullLiteral ? expr2.Type.Name : "null";
                    if (expr1as2 != null && expr2as1 != null)
                    {
                        throw this.ParseError(errorPos, Res.BothTypesConvertToOther, type1, type2);
                    }

                    throw this.ParseError(errorPos, Res.NeitherTypeConvertsToOther, type1, type2);
                }
            }

            return Expression.Condition(test, expr1, expr2);
        }

        private Expression GenerateConversion(Expression expr, Type type, int errorPos)
        {
            Type exprType = expr.Type;
            if (exprType == type)
            {
                return expr;
            }

            if (exprType.IsValueType && type.IsValueType)
            {
                if ((IsNullableType(exprType) || IsNullableType(type)) && GetNonNullableType(exprType) == GetNonNullableType(type))
                {
                    return Expression.Convert(expr, type);
                }

                if ((IsNumericType(exprType) || IsEnumType(exprType)) && IsNumericType(type) || IsEnumType(type))
                {
                    return Expression.ConvertChecked(expr, type);
                }
            }

            if (exprType.IsAssignableFrom(type) || type.IsAssignableFrom(exprType) || exprType.IsInterface || type.IsInterface)
            {
                return Expression.Convert(expr, type);
            }

            throw this.ParseError(errorPos, Res.CannotConvertValue, GetTypeName(exprType), GetTypeName(type));
        }

        private Expression GenerateEqual(Expression left, Expression right)
        {
            return Expression.Equal(left, right);
        }

        private Expression GenerateGreaterThan(Expression left, Expression right)
        {
            if (left.Type == typeof(string))
            {
                return Expression.GreaterThan(this.GenerateStaticMethodCall("Compare", left, right), Expression.Constant(0));
            }

            return Expression.GreaterThan(left, right);
        }

        private Expression GenerateGreaterThanEqual(Expression left, Expression right)
        {
            if (left.Type == typeof(string))
            {
                return Expression.GreaterThanOrEqual(this.GenerateStaticMethodCall("Compare", left, right), Expression.Constant(0));
            }

            return Expression.GreaterThanOrEqual(left, right);
        }

        private Expression GenerateLessThan(Expression left, Expression right)
        {
            if (left.Type == typeof(string))
            {
                return Expression.LessThan(this.GenerateStaticMethodCall("Compare", left, right), Expression.Constant(0));
            }

            return Expression.LessThan(left, right);
        }

        private Expression GenerateLessThanEqual(Expression left, Expression right)
        {
            if (left.Type == typeof(string))
            {
                return Expression.LessThanOrEqual(this.GenerateStaticMethodCall("Compare", left, right), Expression.Constant(0));
            }

            return Expression.LessThanOrEqual(left, right);
        }

        private Expression GenerateNotEqual(Expression left, Expression right)
        {
            return Expression.NotEqual(left, right);
        }

        private Expression GenerateStaticMethodCall(string methodName, Expression left, Expression right)
        {
            return Expression.Call(null, this.GetStaticMethod(methodName, left, right), new[] { left, right });
        }

        private Expression GenerateStringConcat(Expression left, Expression right)
        {
            return Expression.Call(
                null,
                typeof(string).GetMethod("Concat", new[] { typeof(object), typeof(object) }),
                new[] { left, right });
        }

        private Expression GenerateSubtract(Expression left, Expression right)
        {
            return Expression.Subtract(left, right);
        }

        //UNDONE: Extract extension methods dynamically instead of relying on statically defined subset in code see IEnumerableSignatures 
        private IEnumerable<MethodInfo> GetExtensionMethods(Type extendedType, string methodName)
        {
            //var query = from type in typeof(System.Linq.Enumerable).
            //            where type.IsSealed && !type.IsGenericType && !type.IsNested
            var query =
                from method in typeof(System.Linq.Enumerable).GetMethods(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic)
                where method.IsDefined(typeof(ExtensionAttribute), false)
                where method.Name == methodName
                //where method.GetParameters()[0].ParameterType == extendedType
                select method;
            return query;
        }

        private string GetIdentifier()
        {
            this.ValidateToken(TokenId.Identifier, Res.IdentifierExpected);
            string id = this.token.text;
            if (id.Length > 1 && id[0] == '@')
            {
                id = id.Substring(1);
            }

            return id;
        }

        private string GetPropertyLanguageSpecific(string propertyName, CultureInfo cultureInfo)
        {
            var property = this.it.Type.GetProperty(propertyName);
            /*
            if (property != null)
            {
                var attribute = property.GetCustomAttribute(typeof(MultilanguageAttribute));
                if (attribute != null)
                {
                    var language = cultureInfo.TwoLetterISOLanguageName.ToCharArray();
                    language[0] = char.ToUpper(language[0]);
                    return propertyName + "_" + new string(language);
                }
            }
            */
            return propertyName;
        }

        private MethodInfo GetStaticMethod(string methodName, Expression left, Expression right)
        {
            return left.Type.GetMethod(methodName, new[] { left.Type, right.Type });
        }

        private Exception IncompatibleOperandsError(string opName, Expression left, Expression right, int pos)
        {
            return this.ParseError(pos, Res.IncompatibleOperands, opName, GetTypeName(left.Type), GetTypeName(right.Type));
        }

        private bool IsApplicable(MethodData method, Expression[] args)
        {
            if (method.Parameters.Length != args.Length)
            {
                return false;
            }

            var promotedArgs = new Expression[args.Length];
            for (int i = 0; i < args.Length; i++)
            {
                ParameterInfo pi = method.Parameters[i];
                if (pi.IsOut)
                {
                    return false;
                }

                Expression promoted = this.PromoteExpression(args[i], pi.ParameterType, false);
                if (promoted == null)
                {
                    return false;
                }

                promotedArgs[i] = promoted;
            }

            method.Args = promotedArgs;
            return true;
        }

        private void NextChar()
        {
            if (this.textPos < this.textLen)
            {
                this.textPos++;
            }

            this.ch = this.textPos < this.textLen ? this.text[this.textPos] : '\0';
        }

        private void NextToken()
        {
            while (char.IsWhiteSpace(this.ch))
            {
                this.NextChar();
            }

            TokenId t;
            int tokenPos = this.textPos;
            switch (this.ch)
            {
                case '!':
                    this.NextChar();
                    if (this.ch == '=')
                    {
                        this.NextChar();
                        t = TokenId.ExclamationEqual;
                    }
                    else
                    {
                        t = TokenId.Exclamation;
                    }

                    break;
                case '%':
                    this.NextChar();
                    t = TokenId.Percent;
                    break;
                case '&':
                    this.NextChar();
                    if (this.ch == '&')
                    {
                        this.NextChar();
                        t = TokenId.DoubleAmphersand;
                    }
                    else
                    {
                        t = TokenId.Amphersand;
                    }

                    break;
                case '(':
                    this.NextChar();
                    t = TokenId.OpenParen;
                    break;
                case ')':
                    this.NextChar();
                    t = TokenId.CloseParen;
                    break;
                case '*':
                    this.NextChar();
                    t = TokenId.Asterisk;
                    break;
                case '+':
                    this.NextChar();
                    t = TokenId.Plus;
                    break;
                case ',':
                    this.NextChar();
                    t = TokenId.Comma;
                    break;
                case '-':
                    this.NextChar();
                    t = TokenId.Minus;
                    break;
                case '.':
                    this.NextChar();
                    t = TokenId.Dot;
                    break;
                case '/':
                    this.NextChar();
                    t = TokenId.Slash;
                    break;
                case ':':
                    this.NextChar();
                    t = TokenId.Colon;
                    break;
                case '<':
                    this.NextChar();
                    if (this.ch == '=')
                    {
                        this.NextChar();
                        t = TokenId.LessThanEqual;
                    }
                    else
                    {
                        t = TokenId.LessThan;
                    }

                    break;
                case '=':
                    this.NextChar();
                    if (this.ch == '=')
                    {
                        this.NextChar();
                        t = TokenId.DoubleEqual;
                    }
                    else if (this.ch == '>')
                    {
                        this.NextChar();
                        t = TokenId.Lambda;
                    }
                    else
                    {
                        t = TokenId.Equal;
                    }

                    break;
                case '>':
                    this.NextChar();
                    if (this.ch == '=')
                    {
                        this.NextChar();
                        t = TokenId.GreaterThanEqual;
                    }
                    else
                    {
                        t = TokenId.GreaterThan;
                    }

                    break;
                case '?':
                    this.NextChar();
                    t = TokenId.Question;
                    break;
                case '[':
                    this.NextChar();
                    t = TokenId.OpenBracket;
                    break;
                case ']':
                    this.NextChar();
                    t = TokenId.CloseBracket;
                    break;
                case '|':
                    this.NextChar();
                    if (this.ch == '|')
                    {
                        this.NextChar();
                        t = TokenId.DoubleBar;
                    }
                    else
                    {
                        t = TokenId.Bar;
                    }

                    break;
                case '"':
                case '\'':
                    char quote = this.ch;
                    do
                    {
                        this.NextChar();
                        while (this.textPos < this.textLen && this.ch != quote)
                        {
                            this.NextChar();
                        }

                        if (this.textPos == this.textLen)
                        {
                            throw this.ParseError(this.textPos, Res.UnterminatedStringLiteral);
                        }

                        this.NextChar();
                    }
                    while (this.ch == quote);
                    t = TokenId.StringLiteral;
                    break;
                default:
                    if (char.IsLetter(this.ch) || this.ch == '@' || this.ch == '_')
                    {
                        do
                        {
                            this.NextChar();
                        }
                        while (char.IsLetterOrDigit(this.ch) || this.ch == '_');
                        t = TokenId.Identifier;
                        break;
                    }

                    if (char.IsDigit(this.ch))
                    {
                        t = TokenId.IntegerLiteral;
                        do
                        {
                            this.NextChar();
                        }
                        while (char.IsDigit(this.ch));
                        if (this.ch == '.')
                        {
                            t = TokenId.RealLiteral;
                            this.NextChar();
                            this.ValidateDigit();
                            do
                            {
                                this.NextChar();
                            }
                            while (char.IsDigit(this.ch));
                        }

                        if (this.ch == 'E' || this.ch == 'e')
                        {
                            t = TokenId.RealLiteral;
                            this.NextChar();
                            if (this.ch == '+' || this.ch == '-')
                            {
                                this.NextChar();
                            }

                            this.ValidateDigit();
                            do
                            {
                                this.NextChar();
                            }
                            while (char.IsDigit(this.ch));
                        }

                        if (this.ch == 'F' || this.ch == 'f')
                        {
                            this.NextChar();
                        }

                        break;
                    }

                    if (this.textPos == this.textLen)
                    {
                        t = TokenId.End;
                        break;
                    }

                    throw this.ParseError(this.textPos, Res.InvalidCharacter, this.ch);
            }

            this.token.id = t;
            var tokenText = this.text.Substring(tokenPos, this.textPos - tokenPos);
            this.token.param = tokenText;
            this.token.text = t != TokenId.Identifier ? tokenText : this.GetPropertyLanguageSpecific(tokenText, null);
            //: this.GetPropertyLanguageSpecific(tokenText, this.languageSupport.GetCurrentLanguage().CultureInfo);
            this.token.pos = tokenPos;
        }

        // +, -, & operators
        private Expression ParseAdditive()
        {
            Expression left = this.ParseMultiplicative();
            while (this.token.id == TokenId.Plus || this.token.id == TokenId.Minus || this.token.id == TokenId.Amphersand)
            {
                Token op = this.token;
                this.NextToken();
                Expression right = this.ParseMultiplicative();
                switch (op.id)
                {
                    case TokenId.Plus:
                        if (left.Type == typeof(string) || right.Type == typeof(string))
                        {
                            goto case TokenId.Amphersand;
                        }

                        this.CheckAndPromoteOperands(typeof(IAddSignatures), op.text, ref left, ref right, op.pos);
                        left = this.GenerateAdd(left, right);
                        break;
                    case TokenId.Minus:
                        this.CheckAndPromoteOperands(typeof(ISubtractSignatures), op.text, ref left, ref right, op.pos);
                        left = this.GenerateSubtract(left, right);
                        break;
                    case TokenId.Amphersand:
                        left = this.GenerateStringConcat(left, right);
                        break;
                }
            }

            return left;
        }

        private Expression ParseAggregate(Expression instance, Type elementType, string methodName, int errorPos)
        {
            ParameterExpression outerIt = this.it;
            ParameterExpression innerIt = this.it == null
                                              ? Expression.Parameter(elementType, string.Empty)
                                              : Expression.Parameter(elementType, this.it.ToString());
            this.it = innerIt;
            Expression[] args = this.ParseArgumentList();
            this.it = outerIt;
            MethodBase signature;
            if (this.FindMethod(typeof(IEnumerableSignatures), methodName, false, args, out signature) != 1)
            {
                throw this.ParseError(errorPos, Res.NoApplicableAggregate, methodName);
            }

            Type[] typeArgs;

            switch (signature.Name)
            {
                case "Min":
                case "Max":
                    typeArgs = new[] { elementType, args[0].Type };
                    break;
                case "OrderBy":
                    typeArgs = new[] { elementType, args[0].Type.GetGenericArguments().Last() };
                    break;
                case "OrderByDescending":
                    typeArgs = new[] { elementType, args[0].Type.GetGenericArguments().Last() };
                    break;
                default:
                    typeArgs = new[] { elementType };
                    break;
            }

            if (args.Length == 0)
            {
                args = new[] { instance };
            }
            else
            {
                if (args[0].NodeType == ExpressionType.Constant)
                {
                    args = new[] { instance, args[0] };
                }
                else
                {
                    if (signature.GetParameters().Last().ParameterType == typeof(System.Linq.IQueryable)
                        || signature.GetParameters().Last().ParameterType == typeof(IEnumerable) || args[0] is LambdaExpression)
                    {
                        args = new[] { instance, args[0] };
                    }
                    else
                    {
                        args = new[] { instance, Expression.Lambda(args[0], innerIt) };
                    }
                }
            }

            return Expression.Call(typeof(Queryable), signature.Name, typeArgs, args);
        }

        private Expression[] ParseArgumentList()
        {
            this.ValidateToken(TokenId.OpenParen, Res.OpenParenExpected);
            this.NextToken();
            Expression[] args = this.token.id != TokenId.CloseParen ? this.ParseArguments() : new Expression[0];
            this.ValidateToken(TokenId.CloseParen, Res.CloseParenOrCommaExpected);
            this.NextToken();
            return args;
        }

        private Expression[] ParseArguments()
        {
            var argList = new List<Expression>();
            while (true)
            {
                argList.Add(this.ParseExpression());
                if (this.token.id != TokenId.Comma)
                {
                    break;
                }

                this.NextToken();
            }

            return argList.ToArray();
        }

        // =, ==, !=, <>, >, >=, <, <= operators
        private Expression ParseComparison()
        {
            Expression left = this.ParseAdditive();
            while (this.token.id == TokenId.Equal || this.token.id == TokenId.DoubleEqual || this.token.id == TokenId.ExclamationEqual
                   || this.token.id == TokenId.LessGreater || this.token.id == TokenId.GreaterThan
                   || this.token.id == TokenId.GreaterThanEqual || this.token.id == TokenId.LessThan
                   || this.token.id == TokenId.LessThanEqual)
            {
                Token op = this.token;
                this.NextToken();
                Expression right = this.ParseAdditive();
                bool isEquality = op.id == TokenId.Equal || op.id == TokenId.DoubleEqual || op.id == TokenId.ExclamationEqual
                                  || op.id == TokenId.LessGreater;
                if (isEquality && !left.Type.IsValueType && !right.Type.IsValueType)
                {
                    if (left.Type != right.Type)
                    {
                        if (left.Type.IsAssignableFrom(right.Type))
                        {
                            right = Expression.Convert(right, left.Type);
                        }
                        else if (right.Type.IsAssignableFrom(left.Type))
                        {
                            left = Expression.Convert(left, right.Type);
                        }
                        else
                        {
                            throw this.IncompatibleOperandsError(op.text, left, right, op.pos);
                        }
                    }
                }
                else if (IsEnumType(left.Type) || IsEnumType(right.Type))
                {
                    if (left.Type != right.Type)
                    {
                        Expression e;
                        if ((e = this.PromoteExpression(right, left.Type, true)) != null)
                        {
                            right = e;
                        }
                        else if ((e = this.PromoteExpression(left, right.Type, true)) != null)
                        {
                            left = e;
                        }
                        else
                        {
                            throw this.IncompatibleOperandsError(op.text, left, right, op.pos);
                        }
                    }
                }
                else
                {
                    this.CheckAndPromoteOperands(
                        isEquality ? typeof(IEqualitySignatures) : typeof(IRelationalSignatures),
                        op.text,
                        ref left,
                        ref right,
                        op.pos);
                }

                switch (op.id)
                {
                    case TokenId.Equal:
                    case TokenId.DoubleEqual:
                        left = this.GenerateEqual(left, right);
                        break;
                    case TokenId.ExclamationEqual:
                    case TokenId.LessGreater:
                        left = this.GenerateNotEqual(left, right);
                        break;
                    case TokenId.GreaterThan:
                        left = this.GenerateGreaterThan(left, right);
                        break;
                    case TokenId.GreaterThanEqual:
                        left = this.GenerateGreaterThanEqual(left, right);
                        break;
                    case TokenId.LessThan:
                        left = this.GenerateLessThan(left, right);
                        break;
                    case TokenId.LessThanEqual:
                        left = this.GenerateLessThanEqual(left, right);
                        break;
                }
            }

            return left;
        }

        private Expression ParseElementAccess(Expression expr)
        {
            int errorPos = this.token.pos;
            this.ValidateToken(TokenId.OpenBracket, Res.OpenParenExpected);
            this.NextToken();
            Expression[] args = this.ParseArguments();
            this.ValidateToken(TokenId.CloseBracket, Res.CloseBracketOrCommaExpected);
            this.NextToken();
            if (expr.Type.IsArray)
            {
                if (expr.Type.GetArrayRank() != 1 || args.Length != 1)
                {
                    throw this.ParseError(errorPos, Res.CannotIndexMultiDimArray);
                }

                Expression index = this.PromoteExpression(args[0], typeof(int), true);
                if (index == null)
                {
                    throw this.ParseError(errorPos, Res.InvalidIndex);
                }

                return Expression.ArrayIndex(expr, index);
            }
            else
            {
                MethodBase mb;
                switch (this.FindIndexer(expr.Type, args, out mb))
                {
                    case 0:
                        throw this.ParseError(errorPos, Res.NoApplicableIndexer, GetTypeName(expr.Type));
                    case 1:
                        return Expression.Call(expr, (MethodInfo)mb, args);
                    default:
                        throw this.ParseError(errorPos, Res.AmbiguousIndexerInvocation, GetTypeName(expr.Type));
                }
            }
        }

        private Exception ParseError(string format, params object[] args)
        {
            return this.ParseError(this.token.pos, format, args);
        }

        private Exception ParseError(int pos, string format, params object[] args)
        {
            return new ParseException(string.Format(System.Globalization.CultureInfo.CurrentCulture, format, args), pos);
        }

        // ?: operator
        private Expression ParseExpression()
        {
            int errorPos = this.token.pos;
            Expression expr = this.ParseLambda();
            if (this.token.id == TokenId.Question)
            {
                this.NextToken();
                Expression expr1 = this.ParseExpression();
                this.ValidateToken(TokenId.Colon, Res.ColonExpected);
                this.NextToken();
                Expression expr2 = this.ParseExpression();
                expr = this.GenerateConditional(expr, expr1, expr2, errorPos);
            }

            return expr;
        }

        private Expression ParseIdentifier()
        {
            this.ValidateToken(TokenId.Identifier);
            object value;
            if (keywords.TryGetValue(this.token.text, out value))
            {
                if (value is Type)
                {
                    return this.ParseTypeAccess((Type)value);
                }

                if (value == (object)keywordIt)
                {
                    return this.ParseIt();
                }

                if (value == (object)keywordIif)
                {
                    return this.ParseIif();
                }

                if (value == (object)keywordNew)
                {
                    return this.ParseNew();
                }

                this.NextToken();
                return (Expression)value;
            }

            //if (symbols.TryGetValue(token.text, out value) ||
            //    externals != null && externals.TryGetValue(token.text, out value)) {
            if (this.symbols.TryGetValue(this.token.text, out value)
                || this.externals != null && this.externals.TryGetValue(this.token.text, out value)
                || this.internals.TryGetValue(this.token.text, out value))
            {
                var expr = value as Expression;
                if (expr == null)
                {
                    expr = Expression.Constant(value);
                }
                else
                {
                    var lambda = expr as LambdaExpression;
                    if (lambda != null)
                    {
                        return this.ParseLambdaInvocation(lambda);
                    }
                }

                this.NextToken();
                return expr;
            }

            if (this.it != null)
            {
                return this.ParseMemberAccess(null, this.it);
            }

            throw this.ParseError(Res.UnknownIdentifier, this.token.text);
        }

        private Expression ParseIif()
        {
            int errorPos = this.token.pos;
            this.NextToken();
            Expression[] args = this.ParseArgumentList();
            if (args.Length != 3)
            {
                throw this.ParseError(errorPos, Res.IifRequiresThreeArgs);
            }

            return this.GenerateConditional(args[0], args[1], args[2], errorPos);
        }

        private Expression ParseIntegerLiteral()
        {
            this.ValidateToken(TokenId.IntegerLiteral);
            string text = this.token.text;
            if (text[0] != '-')
            {
                ulong value;
                if (!ulong.TryParse(text, out value))
                {
                    throw this.ParseError(Res.InvalidIntegerLiteral, text);
                }

                this.NextToken();
                if (value <= (ulong)int.MaxValue)
                {
                    return this.CreateLiteral((int)value, text);
                }

                if (value <= (ulong)uint.MaxValue)
                {
                    return this.CreateLiteral((uint)value, text);
                }

                if (value <= (ulong)long.MaxValue)
                {
                    return this.CreateLiteral((long)value, text);
                }

                return this.CreateLiteral(value, text);
            }
            else
            {
                long value;
                if (!long.TryParse(text, out value))
                {
                    throw this.ParseError(Res.InvalidIntegerLiteral, text);
                }

                this.NextToken();
                if (value >= int.MinValue && value <= int.MaxValue)
                {
                    return this.CreateLiteral((int)value, text);
                }

                return this.CreateLiteral(value, text);
            }
        }

        private Expression ParseIt()
        {
            if (this.it == null)
            {
                throw this.ParseError(Res.NoItInScope);
            }

            this.NextToken();
            return this.it;
        }

        /// <summary>
        ///     =&gt; operator
        ///     Added Support for projection operator
        /// </summary>
        /// <returns>
        ///     The <see cref="Expression" />.
        /// </returns>
        private Expression ParseLambda()
        {
            int errorPos = this.token.pos;
            Expression expr = this.ParseLogicalOr();
            if (this.token.id == TokenId.Lambda)
            {
                if (this.token.id == TokenId.Lambda && this.it.Type == expr.Type)
                {
                    this.NextToken();
                    if (this.token.id == TokenId.Identifier || this.token.id == TokenId.OpenParen)
                    {
                        var right = this.ParseExpression();
                        return Expression.Lambda(right, new[] { (ParameterExpression)expr });
                    }

                    this.ValidateToken(TokenId.OpenParen, Res.OpenParenExpected);
                }
            }

            return expr;
        }

        private Expression ParseLambdaInvocation(LambdaExpression lambda)
        {
            int errorPos = this.token.pos;
            this.NextToken();
            Expression[] args = this.ParseArgumentList();
            MethodBase method;
            if (this.FindMethod(lambda.Type, "Invoke", false, args, out method) != 1)
            {
                throw this.ParseError(errorPos, Res.ArgsIncompatibleWithLambda);
            }

            return Expression.Invoke(lambda, args);
        }

        // &&, and operator
        private Expression ParseLogicalAnd()
        {
            Expression left = this.ParseComparison();
            while (this.token.id == TokenId.DoubleAmphersand || this.TokenIdentifierIs("and"))
            {
                Token op = this.token;
                this.NextToken();
                Expression right = this.ParseComparison();
                this.CheckAndPromoteOperands(typeof(ILogicalSignatures), op.text, ref left, ref right, op.pos);
                left = Expression.AndAlso(left, right);
            }

            return left;
        }

        // ||, or operator
        private Expression ParseLogicalOr()
        {
            Expression left = this.ParseLogicalAnd();
            while (this.token.id == TokenId.DoubleBar || this.TokenIdentifierIs("or"))
            {
                Token op = this.token;
                this.NextToken();
                Expression right = this.ParseLogicalAnd();
                this.CheckAndPromoteOperands(typeof(ILogicalSignatures), op.text, ref left, ref right, op.pos);
                left = Expression.OrElse(left, right);
            }

            return left;
        }

        /// <summary>
        /// Parsing begins here
        /// </summary>
        /// <param name="type">
        /// </param>
        /// <param name="instance">
        /// </param>
        /// <returns>
        /// The <see cref="Expression"/>.
        /// </returns>
        private Expression ParseMemberAccess(Type type, Expression instance)
        {
            if (instance != null)
            {
                type = instance.Type;
            }

            int errorPos = this.token.pos;
            string id = this.GetIdentifier();
            this.NextToken();
            if (this.token.id == TokenId.OpenParen)
            {
                if (instance != null && type != typeof(string))
                {
                    Type enumerableType = FindGenericType(typeof(IQueryable<>), type);
                    if (enumerableType != null)
                    {
                        Type elementType = enumerableType.GetGenericArguments()[0];
                        return this.ParseAggregate(instance, elementType, id, errorPos);
                    }
                }

                Expression[] args = this.ParseArgumentList();
                MethodBase mb;
                switch (this.FindMethod(type, id, instance == null, args, out mb))
                {
                    case 0:
                        throw this.ParseError(errorPos, Res.NoApplicableMethod, id, GetTypeName(type));
                    case 1:
                        var method = (MethodInfo)mb;
                        if (!IsPredefinedType(method.DeclaringType))
                        {
                            throw this.ParseError(errorPos, Res.MethodsAreInaccessible, GetTypeName(method.DeclaringType));
                        }

                        if (method.ReturnType == typeof(void))
                        {
                            throw this.ParseError(errorPos, Res.MethodIsVoid, id, GetTypeName(method.DeclaringType));
                        }

                        return Expression.Call(instance, (MethodInfo)method, args);
                    default:
                        throw this.ParseError(errorPos, Res.AmbiguousMethodInvocation, id, GetTypeName(type));
                }
            }
            else
            {
                MemberInfo member = this.FindPropertyOrField(type, id, instance == null);
                //if (member == null)
                //    throw ParseError(errorPos, Res.UnknownPropertyOrField,
                //        id, GetTypeName(type));
                if (member == null)
                {
                    if (this.token.id == TokenId.Lambda && this.it.Type == type)
                    {
                        // This might be an internal variable for use within a lambda expression, so store it as such
                        this.internals.Add(id, this.it);
                        this.NextToken();
                        var right = this.ParseExpression();
                        return right;
                    }
                    else
                    {
                        throw this.ParseError(errorPos, Res.UnknownPropertyOrField, id, GetTypeName(type));
                    }
                }

                return member is PropertyInfo
                           ? Expression.Property(instance, (PropertyInfo)member)
                           : Expression.Field(instance, (FieldInfo)member);
            }
        }

        // *, /, %, mod operators
        private Expression ParseMultiplicative()
        {
            Expression left = this.ParseUnary();
            while (this.token.id == TokenId.Asterisk || this.token.id == TokenId.Slash || this.token.id == TokenId.Percent
                   || this.TokenIdentifierIs("mod"))
            {
                Token op = this.token;
                this.NextToken();
                Expression right = this.ParseUnary();
                this.CheckAndPromoteOperands(typeof(IArithmeticSignatures), op.text, ref left, ref right, op.pos);
                switch (op.id)
                {
                    case TokenId.Asterisk:
                        left = Expression.Multiply(left, right);
                        break;
                    case TokenId.Slash:
                        left = Expression.Divide(left, right);
                        break;
                    case TokenId.Percent:
                    case TokenId.Identifier:
                        left = Expression.Modulo(left, right);
                        break;
                }
            }

            return left;
        }

        private Expression ParseNew()
        {
            this.NextToken();
            this.ValidateToken(TokenId.OpenParen, Res.OpenParenExpected);
            this.NextToken();
            var properties = new List<DynamicProperty>();
            var expressions = new List<Expression>();
            while (true)
            {
                string propName = this.token.param;
                int exprPos = this.token.pos;
                Expression expr = this.ParseExpression();
                if (this.TokenIdentifierIs("as"))
                {
                    this.NextToken();
                    propName = this.GetIdentifier();
                    this.NextToken();
                }
                else
                {
                    var me = expr as MemberExpression;
                    if (me == null)
                    {
                        throw this.ParseError(exprPos, Res.MissingAsClause);
                    }
                }

                expressions.Add(expr);
                properties.Add(new DynamicProperty(propName, expr.Type));
                if (this.token.id != TokenId.Comma)
                {
                    break;
                }

                this.NextToken();
            }

            this.ValidateToken(TokenId.CloseParen, Res.CloseParenOrCommaExpected);
            this.NextToken();
            Type type = DynamicExpression.CreateClass(properties);
            var bindings = new MemberBinding[properties.Count];
            for (int i = 0; i < bindings.Length; i++)
            {
                bindings[i] = Expression.Bind(type.GetProperty(properties[i].Name), expressions[i]);
            }

            return Expression.MemberInit(Expression.New(type), bindings);
        }

        private Expression ParseParenExpression()
        {
            this.ValidateToken(TokenId.OpenParen, Res.OpenParenExpected);
            this.NextToken();
            Expression e = this.ParseExpression();
            this.ValidateToken(TokenId.CloseParen, Res.CloseParenOrOperatorExpected);
            this.NextToken();
            return e;
        }

        private Expression ParsePrimary()
        {
            Expression expr = this.ParsePrimaryStart();
            while (true)
            {
                if (this.token.id == TokenId.Dot)
                {
                    this.NextToken();
                    expr = this.ParseMemberAccess(null, expr);
                }
                else if (this.token.id == TokenId.OpenBracket)
                {
                    expr = this.ParseElementAccess(expr);
                }
                else
                {
                    break;
                }
            }

            return expr;
        }

        private Expression ParsePrimaryStart()
        {
            switch (this.token.id)
            {
                case TokenId.Identifier:
                    return this.ParseIdentifier();
                case TokenId.StringLiteral:
                    return this.ParseStringLiteral();
                case TokenId.IntegerLiteral:
                    return this.ParseIntegerLiteral();
                case TokenId.RealLiteral:
                    return this.ParseRealLiteral();
                case TokenId.OpenParen:
                    return this.ParseParenExpression();
                default:
                    throw this.ParseError(Res.ExpressionExpected);
            }
        }

        private Expression ParseRealLiteral()
        {
            this.ValidateToken(TokenId.RealLiteral);
            string text = this.token.text;
            object value = null;
            char last = text[text.Length - 1];
            if (last == 'F' || last == 'f')
            {
                float f;
                if (float.TryParse(text.Substring(0, text.Length - 1), out f))
                {
                    value = f;
                }
            }
            else
            {
                double d;
                if (double.TryParse(text, out d))
                {
                    value = d;
                }
            }

            if (value == null)
            {
                throw this.ParseError(Res.InvalidRealLiteral, text);
            }

            this.NextToken();
            return this.CreateLiteral(value, text);
        }

        private Expression ParseStringLiteral()
        {
            this.ValidateToken(TokenId.StringLiteral);
            char quote = this.token.text[0];
            string s = this.token.text.Substring(1, this.token.text.Length - 2);
            int start = 0;
            while (true)
            {
                int i = s.IndexOf(quote, start);
                if (i < 0)
                {
                    break;
                }

                s = s.Remove(i, 1);
                start = i + 1;
            }

            if (quote == '\'')
            {
                if (s.Length != 1)
                {
                    throw this.ParseError(Res.InvalidCharacterLiteral);
                }

                this.NextToken();
                return this.CreateLiteral(s[0], s);
            }

            this.NextToken();
            return this.CreateLiteral(s, s);
        }

        private Expression ParseTypeAccess(Type type)
        {
            int errorPos = this.token.pos;
            this.NextToken();
            if (this.token.id == TokenId.Question)
            {
                if (!type.IsValueType || IsNullableType(type))
                {
                    throw this.ParseError(errorPos, Res.TypeHasNoNullableForm, GetTypeName(type));
                }

                type = typeof(Nullable<>).MakeGenericType(type);
                this.NextToken();
            }

            if (this.token.id == TokenId.OpenParen)
            {
                Expression[] args = this.ParseArgumentList();
                MethodBase method;
                switch (this.FindBestMethod(type.GetConstructors(), args, out method))
                {
                    case 0:
                        if (args.Length == 1)
                        {
                            return this.GenerateConversion(args[0], type, errorPos);
                        }

                        throw this.ParseError(errorPos, Res.NoMatchingConstructor, GetTypeName(type));
                    case 1:
                        return Expression.New((ConstructorInfo)method, args);
                    default:
                        throw this.ParseError(errorPos, Res.AmbiguousConstructorInvocation, GetTypeName(type));
                }
            }

            this.ValidateToken(TokenId.Dot, Res.DotOrOpenParenExpected);
            this.NextToken();
            return this.ParseMemberAccess(type, null);
        }

        // -, !, not unary operators
        private Expression ParseUnary()
        {
            if (this.token.id == TokenId.Minus || this.token.id == TokenId.Exclamation || this.TokenIdentifierIs("not"))
            {
                Token op = this.token;
                this.NextToken();
                if (op.id == TokenId.Minus && (this.token.id == TokenId.IntegerLiteral || this.token.id == TokenId.RealLiteral))
                {
                    this.token.text = "-" + this.token.text;
                    this.token.pos = op.pos;
                    return this.ParsePrimary();
                }

                Expression expr = this.ParseUnary();
                if (op.id == TokenId.Minus)
                {
                    this.CheckAndPromoteOperand(typeof(INegationSignatures), op.text, ref expr, op.pos);
                    expr = Expression.Negate(expr);
                }
                else
                {
                    this.CheckAndPromoteOperand(typeof(INotSignatures), op.text, ref expr, op.pos);
                    expr = Expression.Not(expr);
                }

                return expr;
            }

            return this.ParsePrimary();
        }

        private void ProcessParameters(ParameterExpression[] parameters)
        {
            foreach (var pe in parameters)
            {
                if (!string.IsNullOrEmpty(pe.Name))
                {
                    this.AddSymbol(pe.Name, pe);
                }
            }

            if (parameters.Length == 1 && string.IsNullOrEmpty(parameters[0].Name))
            {
                this.it = parameters[0];
            }
        }

        private void ProcessValues(object[] values)
        {
            for (int i = 0; i < values.Length; i++)
            {
                object value = values[i];
                if (i == values.Length - 1 && value is IDictionary<string, object>)
                {
                    this.externals = (IDictionary<string, object>)value;
                }
                else
                {
                    this.AddSymbol("@" + i.ToString(System.Globalization.CultureInfo.InvariantCulture), value);
                }
            }
        }

        private Expression PromoteExpression(Expression expr, Type type, bool exact)
        {
            if (expr.Type == type || ((expr is LambdaExpression) && ((LambdaExpression)expr).ReturnType == type)
                || (expr is LambdaExpression) && type == typeof(LambdaExpression))
            {
                return expr;
            }

            //if (expr.Type == type || ((expr is LambdaExpression) && (type is typeof(LambdaExpression))) return expr;
            if (expr is ConstantExpression)
            {
                var ce = (ConstantExpression)expr;
                if (ce == nullLiteral)
                {
                    if (!type.IsValueType || IsNullableType(type))
                    {
                        return Expression.Constant(null, type);
                    }
                }
                else
                {
                    string text;
                    if (this.literals.TryGetValue(ce, out text))
                    {
                        Type target = GetNonNullableType(type);
                        object value = null;
                        switch (Type.GetTypeCode(ce.Type))
                        {
                            case TypeCode.Int32:
                            case TypeCode.UInt32:
                            case TypeCode.Int64:
                            case TypeCode.UInt64:
                                value = ParseNumber(text, target);
                                break;
                            case TypeCode.Double:
                                if (target == typeof(decimal))
                                {
                                    value = ParseNumber(text, target);
                                }

                                break;
                            case TypeCode.String:
                                value = ParseEnum(text, target);
                                break;
                        }

                        if (value != null)
                        {
                            return Expression.Constant(value, type);
                        }
                    }
                }
            }

            if (IsCompatibleWith(expr.Type, type))
            {
                if (type.IsValueType || exact)
                {
                    return Expression.Convert(expr, type);
                }

                return expr;
            }

            return null;
        }

        private void SetTextPos(int pos)
        {
            this.textPos = pos;
            this.ch = this.textPos < this.textLen ? this.text[this.textPos] : '\0';
        }

        private bool TokenIdentifierIs(string id)
        {
            return this.token.id == TokenId.Identifier && string.Equals(id, this.token.text, StringComparison.OrdinalIgnoreCase);
        }

        private void ValidateDigit()
        {
            if (!char.IsDigit(this.ch))
            {
                throw this.ParseError(this.textPos, Res.DigitExpected);
            }
        }

        private void ValidateToken(TokenId t, string errorMessage)
        {
            if (this.token.id != t)
            {
                throw this.ParseError(errorMessage);
            }
        }

        private void ValidateToken(TokenId t)
        {
            if (this.token.id != t)
            {
                throw this.ParseError(Res.SyntaxError);
            }
        }

        private struct Token
        {
            public TokenId id;

            public string param;

            public int pos;

            public string text;
        }

        private class MethodData
        {
            public Expression[] Args;

            public MethodBase MethodBase;

            public ParameterInfo[] Parameters;
        }
    }

    [ExcludeFromCodeCoverage]
    internal static class Res
    {
        /// <summary>
        ///     The ambiguous constructor invocation.
        /// </summary>
        public const string AmbiguousConstructorInvocation = "Ambiguous invocation of '{0}' constructor";

        /// <summary>
        ///     The ambiguous indexer invocation.
        /// </summary>
        public const string AmbiguousIndexerInvocation = "Ambiguous invocation of indexer in type '{0}'";

        /// <summary>
        ///     The ambiguous method invocation.
        /// </summary>
        public const string AmbiguousMethodInvocation = "Ambiguous invocation of method '{0}' in type '{1}'";

        /// <summary>
        ///     The args incompatible with lambda.
        /// </summary>
        public const string ArgsIncompatibleWithLambda = "Argument list incompatible with lambda expression";

        /// <summary>
        ///     The both types convert to other.
        /// </summary>
        public const string BothTypesConvertToOther = "Both of the types '{0}' and '{1}' convert to the other";

        /// <summary>
        ///     The cannot convert value.
        /// </summary>
        public const string CannotConvertValue = "A value of type '{0}' cannot be converted to type '{1}'";

        /// <summary>
        ///     The cannot index multi dim array.
        /// </summary>
        public const string CannotIndexMultiDimArray = "Indexing of multi-dimensional arrays is not supported";

        /// <summary>
        ///     The close bracket or comma expected.
        /// </summary>
        public const string CloseBracketOrCommaExpected = "']' or ',' expected";

        /// <summary>
        ///     The close paren or comma expected.
        /// </summary>
        public const string CloseParenOrCommaExpected = "')' or ',' expected";

        /// <summary>
        ///     The close paren or operator expected.
        /// </summary>
        public const string CloseParenOrOperatorExpected = "')' or operator expected";

        /// <summary>
        ///     The colon expected.
        /// </summary>
        public const string ColonExpected = "':' expected";

        /// <summary>
        ///     The digit expected.
        /// </summary>
        public const string DigitExpected = "Digit expected";

        /// <summary>
        ///     The dot or open paren expected.
        /// </summary>
        public const string DotOrOpenParenExpected = "'.' or '(' expected";

        /// <summary>
        ///     The duplicate identifier.
        /// </summary>
        public const string DuplicateIdentifier = "The identifier '{0}' was defined more than once";

        /// <summary>
        ///     The expression expected.
        /// </summary>
        public const string ExpressionExpected = "Expression expected";

        /// <summary>
        ///     The expression type mismatch.
        /// </summary>
        public const string ExpressionTypeMismatch = "Expression of type '{0}' expected";

        /// <summary>
        ///     The first expr must be bool.
        /// </summary>
        public const string FirstExprMustBeBool = "The first expression must be of type 'Boolean'";

        /// <summary>
        ///     The identifier expected.
        /// </summary>
        public const string IdentifierExpected = "Identifier expected";

        /// <summary>
        ///     The iif requires three args.
        /// </summary>
        public const string IifRequiresThreeArgs = "The 'iif' function requires three arguments";

        /// <summary>
        ///     The incompatible operand.
        /// </summary>
        public const string IncompatibleOperand = "Operator '{0}' incompatible with operand type '{1}'";

        /// <summary>
        ///     The incompatible operands.
        /// </summary>
        public const string IncompatibleOperands = "Operator '{0}' incompatible with operand types '{1}' and '{2}'";

        /// <summary>
        ///     The invalid character.
        /// </summary>
        public const string InvalidCharacter = "Syntax error '{0}'";

        /// <summary>
        ///     The invalid character literal.
        /// </summary>
        public const string InvalidCharacterLiteral = "Character literal must contain exactly one character";

        /// <summary>
        ///     The invalid index.
        /// </summary>
        public const string InvalidIndex = "Array index must be an integer expression";

        /// <summary>
        ///     The invalid integer literal.
        /// </summary>
        public const string InvalidIntegerLiteral = "Invalid integer literal '{0}'";

        /// <summary>
        ///     The invalid real literal.
        /// </summary>
        public const string InvalidRealLiteral = "Invalid real literal '{0}'";

        /// <summary>
        ///     The method is void.
        /// </summary>
        public const string MethodIsVoid = "Method '{0}' in type '{1}' does not return a value";

        /// <summary>
        ///     The methods are inaccessible.
        /// </summary>
        public const string MethodsAreInaccessible = "Methods on type '{0}' are not accessible";

        /// <summary>
        ///     The missing as clause.
        /// </summary>
        public const string MissingAsClause = "Expression is missing an 'as' clause";

        /// <summary>
        ///     The neither type converts to other.
        /// </summary>
        public const string NeitherTypeConvertsToOther = "Neither of the types '{0}' and '{1}' converts to the other";

        /// <summary>
        ///     The no applicable aggregate.
        /// </summary>
        public const string NoApplicableAggregate = "No applicable aggregate method '{0}' exists";

        /// <summary>
        ///     The no applicable indexer.
        /// </summary>
        public const string NoApplicableIndexer = "No applicable indexer exists in type '{0}'";

        /// <summary>
        ///     The no applicable method.
        /// </summary>
        public const string NoApplicableMethod = "No applicable method '{0}' exists in type '{1}'";

        /// <summary>
        ///     The no it in scope.
        /// </summary>
        public const string NoItInScope = "No 'it' is in scope";

        /// <summary>
        ///     The no matching constructor.
        /// </summary>
        public const string NoMatchingConstructor = "No matching constructor in type '{0}'";

        /// <summary>
        ///     The open bracket expected.
        /// </summary>
        public const string OpenBracketExpected = "'[' expected";

        /// <summary>
        ///     The open paren expected.
        /// </summary>
        public const string OpenParenExpected = "'(' expected";

        /// <summary>
        ///     The parse exception format.
        /// </summary>
        public const string ParseExceptionFormat = "{0} (at index {1})";

        /// <summary>
        ///     The syntax error.
        /// </summary>
        public const string SyntaxError = "Syntax error";

        /// <summary>
        ///     The token expected.
        /// </summary>
        public const string TokenExpected = "{0} expected";

        /// <summary>
        ///     The type has no nullable form.
        /// </summary>
        public const string TypeHasNoNullableForm = "Type '{0}' has no nullable form";

        /// <summary>
        ///     The unknown identifier.
        /// </summary>
        public const string UnknownIdentifier = "Unknown identifier '{0}'";

        /// <summary>
        ///     The unknown property or field.
        /// </summary>
        public const string UnknownPropertyOrField = "No property or field '{0}' exists in type '{1}'";

        /// <summary>
        ///     The unterminated string literal.
        /// </summary>
        public const string UnterminatedStringLiteral = "Unterminated string literal";
    }
}